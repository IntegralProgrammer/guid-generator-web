<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta
      name="description"
      content="GUID generator from patient identifiable information"
    />
    <title>GUID generator</title>
    <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons" />
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500">
    <script src="https://unpkg.com/react@16/umd/react.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@16/umd/react-dom.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/@material-ui/core/umd/material-ui.production.min.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://requirejs.org/docs/release/2.1.5/comments/require.js"></script>
  </head>
  <body>
    <div id="root"></div>
    <script type="text/babel">

require.config({
    paths: {
       "bcrypt": "https://unpkg.com/bcryptjs@2.4.3/dist/bcrypt"
    }
});

require(["bcrypt"], function(bcrypt) {

    const { useState } = window['React'];
    const { TextField, InputAdornment, Icon, Button, IconButton, Typography, makeStyles, Grid, List, ListItem, ListItemText, FormControl, Select, MenuItem, FormHelperText, InputLabel } = window['MaterialUI'];

    const useStyles = makeStyles((theme) => ({
        bform: {
            marginTop: theme.spacing(2),
            marginBottom: theme.spacing(2),
        },
        btextinput: {
            width: theme.spacing(50),
            marginBottom: theme.spacing(0),
            "& .MuiInput-root": {
              alignItems: "start",
            },
        },
        binputIcon: {
            marginTop: theme.spacing(1),
        },
        projectidinput: {
            width: theme.spacing(50),
        },
        formControl: {
            width: theme.spacing(50),
        },
        boutput: {
            width: theme.spacing(70),
            marginBottom: theme.spacing(0),
        },
        bbutton: {
        },
        labelRoot: {
            width: theme.spacing(70),
            color: theme.palette.text.primary,
        },
        selectInputLabel: {
        },
        selectInputIcon : {
            marginTop: theme.spacing(4),
            marginBottom: theme.spacing(-2),
        },
        selectInput: {
            paddingLeft: theme.spacing(4),
        },
        main: {
            margin : theme.spacing(6),
        },
        helperText: {
            lineHeight: "normal",
        },
        listItem: {
            padding: "0",
        },
    }));

    const provinces = ["AB", "BC", "MB", "NB", "NL", "NS", "NT", "NU", "ON", "PE", "QC", "SK", "YT"];
    const dateFormatSpecs = {
        "yyyy-MM-dd" : {"separator" : "-", "dayIndex" : 2, "montIndex" : 1, "yearIndex" : 0},
        "yyyy/MM/dd" : {"separator" : "/", "dayIndex" : 2, "montIndex" : 1, "yearIndex" : 0},
        "yyyy.MM.dd" : {"separator" : ".", "dayIndex" : 2, "montIndex" : 1, "yearIndex" : 0},
        "yyyy MM dd" : {"separator" : " ", "dayIndex" : 2, "montIndex" : 1, "yearIndex" : 0},
        "dd-MM-yyyy" : {"separator" : "-", "dayIndex" : 0, "montIndex" : 1, "yearIndex" : 2},
        "dd/MM/yyyy" : {"separator" : "/", "dayIndex" : 0, "montIndex" : 1, "yearIndex" : 2},
        "dd.MM.yyyy" : {"separator" : ".", "dayIndex" : 0, "montIndex" : 1, "yearIndex" : 2},
        "dd MM yyyy" : {"separator" : " ", "dayIndex" : 0, "montIndex" : 1, "yearIndex" : 2},
        "MM-dd-yyyy" : {"separator" : "-", "dayIndex" : 1, "montIndex" : 0, "yearIndex" : 2},
        "MM/dd/yyyy" : {"separator" : "/", "dayIndex" : 1, "montIndex" : 0, "yearIndex" : 2},
        "MM.dd.yyyy" : {"separator" : ".", "dayIndex" : 1, "montIndex" : 0, "yearIndex" : 2},
        "MM dd yyyy" : {"separator" : " ", "dayIndex" : 1, "montIndex" : 0, "yearIndex" : 2}
    }

    let sampleDate = {y: 2010, m: 12, d:23};
    let menuEntries = {};

    for (let f in dateFormatSpecs) {
      let sampleDateFormatted = [0,0,0];
      let specs = dateFormatSpecs[f];
      sampleDateFormatted[specs.dayIndex] = sampleDate.d;
      sampleDateFormatted[specs.montIndex] = sampleDate.m;
      sampleDateFormatted[specs.yearIndex] = sampleDate.y;
      menuEntries[f] = f + " (" + sampleDateFormatted.join(specs.separator) + ")";
    }

    function GUIDGeneratorComponent() {
        const classes = useStyles();
        const [ binput, setBinput ] = useState();
        const [ projectId, setProjectId ] = useState(new URLSearchParams(window.location.search).get('project_id') || '');
        const [ bhashes, setBhashes ] = useState({});
        const [ validatedData, setValidatedData ] = useState([]);
        const [ dateFormat, setDateFormat ] = useState("yyyy-MM-dd");

        let onDateFormatChange = (value) => {
            setDateFormat(value);
        }

        let validatedateDate = (dateText) => {

          if (!dateText) {
            return false;
          }

          try {

              var splitComponents = dateText.split(dateFormatSpecs[dateFormat].separator);
              if (splitComponents.length != 3) {
                 // The date as to be in the format dd/mm/yyyy
                 return false;
              }

              var day = parseInt(splitComponents[dateFormatSpecs[dateFormat].dayIndex]);
              var month = parseInt(splitComponents[dateFormatSpecs[dateFormat].montIndex]);
              var year = parseInt(splitComponents[dateFormatSpecs[dateFormat].yearIndex]);

              if (isNaN(day) || isNaN(month) || isNaN(year)) {
                  // The day, month and year need to be numbers
                  return false;
              }

              if (day <= 0 || month <= 0 || year <= 0) {
                  //The day, month and year need to be positive values greater than 0
                  return false;
              }

              if (month > 12) {
                  // The month cannot be greater than 12
                  return false;
              }

              // assuming no leap year by default
              var daysPerMonth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
              if (year % 4 == 0 && (year % 100 != 0 || year % 400 == 0)) {
                  // current year is a leap year
                  daysPerMonth[1] = 29;
              }

              if (day > daysPerMonth[month - 1]) {
                  // Number of days are more than those allowed for the month
                  return false;
              }

          } catch (err) {
              console.log(err);
              return false;
          }

          return true;
        }

        // MOD 10 Check Digit algorithm
        let isValidHealthCard = (num) => {

            let calc, i, check, checksum = 0, r = [2,1];

            // iterate on all the numbers in 'num'
            for ( let i=num.length-1; i--; ){
                calc = num.charAt(i) * r[i % r.length];
                // handle cases where it's a 2 digits number
                calc = ((calc/10)|0) + (calc % 10);
                checksum += calc;
            }
            check = (10-(checksum % 10)) % 10; // make sure to get '0' if checksum is '10'
            let checkDigit = num % 10;

            return check == checkDigit;
        }

        // Validate Ontario Health Card
        let validateONHealthCard = (value) => {
            // Remove everyhing except digits
            value = value.replace(/\D+/g, '');

            if (value.length != 10) {
                return {"error" : "Health card number " + value + " is invalid for the province of ON. A 10 digit number is expected."};
            }

            // validate Ontario Health card with the MOD 10 Check Digit algorithm
            if (!isValidHealthCard(value)) {
                return {"error" : "Health card number " + value + " is invalid for the province of ON. Please check the number and try again."};
            }
            return value;
        }

        const healthCardsValidators = { "ON" : validateONHealthCard };

        // Remove spaces, dashes and assume the result is valid (for now).
        let validateDefaultHealthCard = (value) => {
            return value.replace(/\s+/g, '').replace(/-/g, '');
        }

        // There should be 3 pieces per each line: Health card #, Province code, Date of birth, all separated by ','
        let checkInfoCount = (info, index) => {
            if (info.length != 3) {
                return "Line " + index + ", '" + info.join(',') + "', has " + info.length
                    + " component(s) instead of 3. Each line should contain the patient's Health Card number, the province code, and the patient's date of birth.";
            }
            return null;
        }

        // Validate DOB
        let validateDOB = (value) => {
            if (!validatedateDate(value)) {
                return {"error" : "The date of birth " + value + " appears to be invalid. Please enter a correct date of birth in the format " + dateFormat};
            }
            // Replace '\' and space with '-' before encryption
            return value.replace(/\\/g, '-').replace(/\s+/g, '-');
        }

        // Validate Province code
        // Should be one of: AB, BC, MB, NB, NL, NS, NT, NU, ON, PE, QC, SK, YT. Lower case version is accepted.
        let validateProvince = (value) => {
            if (!provinces.includes(value.toUpperCase())) {
                return {"error" : "Province code " + value.toUpperCase() + " is invalid. It should be one of :" + provinces.join(", ") +"."};
            }
            return value.toUpperCase();
        }

        // Input validation and sanitising
        let validate  = () => {
            let value = binput;
            setBhashes({});
            setValidatedData([]);

            if (!value) return;

            let postProcessed = [];

            let lines = value.split('\n');
            for (var [index, line] of lines.entries()) {
                // skip & ignore empty lines
                if (!line) continue;

                let info = line.trim()
                             .split(',')
                             .map( (item) => (item.trim()) )
                             .filter( (item) => (item) );

                // There should be 3 pieces per each line: Health card #, Province code, Date of birth
                let countErr = checkInfoCount(info, index);
                if (countErr) {
                    postProcessed.push({"line" : line + index, "value" : countErr, "isError": true});
                    continue;
                }

                // Validate DOB
                let date = validateDOB(info[2]);
                if (date.error) {
                    postProcessed.push({"line" : line + index, "value": date.error, "isError": true});
                    continue;
                } else {
                    info[2] = date;
                }

                // Validate Province code
                let province = validateProvince(info[1]);
                if (province.error) {
                    postProcessed.push({"line" : line + index, "value": province.error, "isError": true});
                    continue;
                } else {
                    info[1] = province;
                }

                // Validate Health card number y province
                let healthCard = healthCardsValidators[info[1]] ? healthCardsValidators[info[1]](info[0]) : validateDefaultHealthCard(info[0]);
                if (healthCard.error) {
                    postProcessed.push({"line" : line + index, "value": healthCard.error, "isError": true});
                    continue;
                } else {
                    info[0] = healthCard;
                }

                // If the input is found valid, concatenate the post-processed health card number and date of birth and generate the GUID
                postProcessed.push({"line" : line + index, "value": info[0] + info[2]});
            }

            setValidatedData(postProcessed);
        }

        let onSubmit = () => {

            let hashes = {};

            validatedData.forEach( (item, index) => {
                if (item.isError) {
                    hashes[item.line] = item;
                    (Object.keys(hashes).length == validatedData.length) && setBhashes(hashes);
                } else {
                    // Salt is hardcoded here for now
                    bcrypt.hash(item.value + projectId, "$2a$10$biRUcRBR1wroz1r45ORKs.", (err, hash) => {
                        if (err) {
                            console.error(err);
                            return;
                        }

                        hashes[item.line] = {"value" : hash};
                        (Object.keys(hashes).length == validatedData.length) && setBhashes(hashes);
                    })
                }
            })
        }

        return (
            <div className={classes.main}>
                <Typography variant="h3">GUID generator</Typography>
                <Grid container direction="column" wrap="nowrap" spacing={6} className={classes.bform}>
                    <Grid item>
                        <TextField
                          id="projectid"
                          label="Project Id (* optional)"
                          value={projectId}
                          className={classes.projectidinput}
                          onChange={(event) => { setProjectId(event.target.value); setBhashes({}); }}
                          InputProps={{
                              startAdornment: (
                                <InputAdornment position="start">
                                  <Icon color="primary">label</Icon>
                                </InputAdornment>
                              ),
                           }}
                        />
                    </Grid>
                    <Grid item>
                        <TextField
                          multiline
                          inputProps={{rows: 2}}
                          id="binput"
                          value={binput}
                          className={classes.btextinput}
                          onChange={(event) => { setBinput(event.target.value); setBhashes({}); setValidatedData([]);}}
                          onBlur={(event) => {validate()}}
                          helperText="Please enter the health card number, province code, and date of birth as YYYY-MM-DD, separated by ',' for one or more patients, one patient per line. Example:'2345678904,ON,2002-01-23'."
                          label="Health card number,Province code,Date of birth"
                          placeholder="2345678904,ON,2002-01-23
23456789,AB,2003-05-31"
                          InputProps={{
                              startAdornment: (
                                <InputAdornment position="start" className={classes.binputIcon}>
                                  <Icon color="primary">folder_shared</Icon> 
                                </InputAdornment>
                              ),
                          }}
                          InputLabelProps={{
                              classes: {
                                root: classes.labelRoot
                              }
                          }}
                          FormHelperTextProps={{
                            className: classes.helperText
                          }}
                        />
                    </Grid>
                    <Grid item>
                        <FormControl className={classes.formControl}>
                            <InputLabel shrink id="date-format" className={classes.selectInputLabel}>
                                Date format for the dates of birth
                            </InputLabel>
                           <InputAdornment position="start" className={classes.selectInputIcon}>
                              <Icon color="primary">date_range</Icon>
                            </InputAdornment>
                            <Select
                              className={classes.selectInput}
                              value={dateFormat}
                              onChange={(event) => { onDateFormatChange(event.target.value);}}
                              onBlur={(event) => {validate()}}
                            >
                                { Object.keys(menuEntries).map( item =>
                                    <MenuItem value={item}>{menuEntries[item]}</MenuItem>
                                )}
                            </Select>
                            <FormHelperText>Please specify the format of the dates of birth by selecting one of the supported formats</FormHelperText>
                        </FormControl>
                    </Grid>
                    <Grid item>
                        <Button onClick={() => onSubmit()} variant="contained" color="primary" disabled={binput?.trim().length == 0} className={classes.bbutton}>Generate GUIDs</Button>
                    </Grid>
                </Grid>
                { Object.keys(bhashes).length > 0 &&
                    <List>
                        { validatedData.map( item =>
                            <ListItem className={classes.listItem}>
                                <ListItemText primary={bhashes[item.line].value} style={{color: bhashes[item.line].isError ? 'red' : 'black'}} />
                            </ListItem>
                        )}
                    </List>
                }
            </div>
        );
    }

    ReactDOM.render(
        <GUIDGeneratorComponent/>,
            document.querySelector('#root')
    );

});

    </script>
  </body>
</html>
